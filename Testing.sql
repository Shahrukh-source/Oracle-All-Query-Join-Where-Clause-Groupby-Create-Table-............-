<<<<<LEC 3
create table company1(employe_id int not null,ename varchar(255),last_name varchar(255),depatment varchar(255),job_id varchar(255))

INSERT INTO employees VALUES (1,'shahrukh',"khan","skh@gmail.com",54666596,2022-10-21,ad-llb,"40000","5433","78655","02");

select* from company1
SELECT LAST_NAME, LOLWER(LAST_NAME) FROM EMPLOYEES;
con hr/hr
SELECT * FROM TAB
DESC employees
# case manipulation function use for case change
SELECT LAST_NAME, LOWER(LAST_NAME) FROM EMPLOYEES;
SELECT LAST_NAME, UPPER(LAST_NAME) FROM EMPLOYEES;
SELECT FIRST_NAME, LOWER(FIRST_NAME)FROM JOBS;

SELECT LAST_NAME, LOWER(LAST_NAME) FROM EMPLOYEES;
select last_name, upper(last_name),initcap(last_name) from employees
select first_name, lower(last_name) "lower", initcap(last_name) "initcap" from employees
select first_name, lower(last_name) "lower", initcap(first_name) "initcap" from employees

dummy table is dual(one column and one row use for calculation purpose)
select upper('shahrukh khan') from dual; 

select 678+625 from employees;
select 684+954 from dual;

desc dual;

select user from dual;
select user from employees;

# i have no idea the case are available which form
select * from employees
where lower(last_name) = "scott";

select * from employees
where last_name = "khan"

#character manipulation function
#|| maximum column concate over here
select last_name || job from epmloyees

# only two column concat over here
<<<CONCAT USE FOR JOIN TWO COLUMN
select concat(first_name,last_name) from employees;
select concat(first_name||last_name,phone_number) from employees
select concat(job_id,first_name) from employees;
<<<SUBSTR
select SUBSTR('hellowworld',1,6) from DUAL;
select SUBSTR('shahrukhkhan',4,7) from dual;
select SUBSTR('shahrukhkhan',-4) from dual;
select SUBSTR('shahrukhkhan',-4,2) from dual;

SELECT FIRST_NAME,SUBSTR(LAST_NAME,1,2) FROM EMPLOYEES

SELECT * FROM EMPLOYEES
WHERE SUBSTR(HIREDATE,6,2)=81

SELECT * FROM EMPLOYEES
WHERE SUBSTR(HIREDATE,-2)=81

<<<<<<<LENGTH
SELECT FIRST_NAME , LENGTH(FIRST_NAME) FROM EMPLOYEES
SELECT LAST_NAME, LENGTH(LAST_NAME) FROM EMPLOYEES

SELECT * FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME)=5;
SELECT FIRST_NAME,LENGTH(LAST_NAME),LENGTH(HIRE_DATE) FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME)=5;
<<<<<INTSTR
SELECT LAST_NAME, INSTR(LAST_NAME,'S') FROM EMPLOYEES;
SELECT FIRST_NAME,INSTR(FIRST_NAME,'A') "INSTR" FROM EMPLOYEES;
SELECT FIRST_NAME,INSTR(FIRST_NAME,'r',1,2) "INSTR" FROM EMPLOYEES;
SELECT INSTR('BIGBUBLEGUM','B') FROM DUAL;
SELECT INSTR('BIGBUBLEGUM','B',1,3) FROM DUAL;
SELECT INSTR('BIGBUBLEGUM','B',2,2) FROM DUAL;
SELECT INSTR('BIGBUBLEGUM','B',-1,2) FROM DUAL;
SELECT INSTR('BIGBUBLEGUM','B',-1,3) FROM DUAL;
SELECT INSTR('BIGBUBLEGUM','B',-7,1) FROM DUAL;
SELECT LENGTH(0) "ZERO",
LENGTH(' ') "SPACE",
LENGTH(NULL)'NULL'  ?????
FROM DUAL;
#COUNT FROM LEFT SIDE BUT GIVEN POSITION FROM RIGHT SIDE
#1= START FROM 1,2= FIND POSITION OF SECOND TIME<<<<<<

#<<<LPAD
SELECT FIRST_NAME,LPAD(SALARY,10,'*') FROM EMPLOYEES;
#<<<<RPAD
SELECT FIRST_NAME,RPAD(SALARY,10,'*') FROM EMPLOYEES;

SELECT FIRST_NAME,LPAD(SALARY,10,'*'),RPAD(SALARY,10,'X') FROM EMPLOYEES
<<<<REPLACE

SELECT LAST_NAME, REPLACE('STEVEN,NEENA','HEA','P') FROM EMPLOYEES;
SELECT LAST_NAME, REPLACE(LAST_NAME,'A','B') FROM EMPLOYEES;
SELECT LAST_NAME, REPLACE(LAST_NAME,'A','ABC') FROM EMPLOYEES;
SELECT LAST_NAME, REPLACE(LAST_NAME,'A','ABC') FROM EMPLOYEES;
SELECT LAST_NAME, REPLACE('KING AND AUSTIN','N','B') FROM EMPLOYEES;

<<<<TRIM
SELECT TRIM('H' FROM 'HELLOWWORLD') FROM DUAL;
SELECT TRIM('H' FROM 'HELLOWWORLDH') FROM DUAL;
SELECT TRIM('H' FROM 'HELLOWHWORLDHHH') FROM DUAL;
SELECT TRIM(LEADING 'H' FROM 'HELLOWHWORLDHHH') FROM DUAL;<<<<LEADING(REMOVE FIRST H)
SELECT TRIM(TRAILING 'H' FROM 'HELLOWHWORLDHHH') FROM DUAL;<<<<<TRAILING(REMOVE LAST H)


SELECT employee_id, CONCAT(first_name, last_name) NAME, 
job_id, LENGTH (last_name), 
INSTR(last_name, 'a') "Contains 'a'?"
FROM employees
WHERE SUBSTR(job_id, 4) = 'REP';

COL "SUBSTR" FORMAT A30;<<<<

<<<<<<<<<<<<<<<NUMBER FUNCTIION>>>>>>>>>>>>>>>>>>>>
<<ROUND(APPLY ON NUMBER)
SELECT ROUND(45.9234,2) "ROUND" FROM DUAL;
SELECT ROUND(45.9234,3) FROM DUAL;
<< AFTER DECIMAL PASSING 3(SEE AFTER NUMBER) MORETHEN FROM 5 THEREFORE ONE NUM IS INCREASE
SELECT ROUND(45.9246,3) FROM DUAL;
SELECT ROUND(45.9243,3) FROM DUAL;
SELECT ROUND(45.9245,3) FROM DUAL;
SELECT ROUND(45.9245,1) FROM DUAL;
SELECT ROUND(45.9245,0) FROM DUAL;<<GRETERTHAN

<< IF PASSING -1 SO THOSE ROUND BY 10 (SET IN 40 AND 50, BEFORE 5(40) AND 5 OR AFTER 5(50))
SELECT ROUND(45.9245,-1) FROM DUAL;
SELECT ROUND(44.9245,-1) FROM DUAL;
SELECT ROUND(142.9245,-1) FROM DUAL;
SELECT ROUND(1146.9245,-1) FROM DUAL;
SELECT ROUND(1244.9245,-2) FROM DUAL;<<<<< ROUND ACORDING TO 100
SELECT ROUND(1604.9245,-2) FROM DUAL;
SELECT ROUND(1146.9245,-2) FROM DUAL;
SELECT ROUND(1604.9245,-3) FROM DUAL;<<<<ROUND ACORDING TO 1000
SELECT ROUND(1404.9245,-3) FROM DUAL;

<<<<TRUNC(NOT ANY CHANGE ONLY GIVEN DECIMAL NUMBER ACORDING TO PASSING THE NUMBER1,2,3,....)
SELECT TRUNC(45.9999,2) FROM DUAL;
SELECT TRUNC(45.9999,-1) FROM DUAL; <<REMOVE NUMBER GET 40
SELECT TRUNC(45.9999,-2) FROM DUAL; <<REMOVE NUMBER GET 0
SELECT TRUNC(145.9999,-2) FROM DUAL;
SELECT TRUNC(45.9999,0) FROM DUAL;

<<<MOD FUNCTION (GIVEN REMINDER VALUE)
SELECT MOD(455,12) FROM DUAL;
SELECT MOD(5300,1000) FROM DUAL;
SELECT MOD(5000,1000) FROM DUAL;
SELECT LAST_NAME,SALARY,MOD(SALARY,1000) FROM EMPLOYEES;

SELECT last_name, salary, MOD(salary, 5000)
FROM employees 
WHERE job_id = 'SA_REP';

<<<<<<<<<<<<<<< WORKING WITH DATE>>>>>>>>>>>>>>>>>>

SELECT SYSDATE, SYSDATE+3 FROM DUAL;
SELECT SYSDATE, SYSDATE-3 FROM DUAL;
SELECT SYSDATE, SYSDATE - (3/24) FROM DUAL;

<<<ALTER SESSION SET NLS_DATE_FORMAT='DD-MON-RR HH24:MI:SS'; FOR TIME
<<<<ALTER SESSION SET NLS_DATE_FORMAT='DD-MON-RR HH24:MIN:SS';

SELECT SYSDATE, SYSDATE + (3/24) FROM DUAL;
SELECT SYSDATE, SYSDATE - (3/24) FROM DUAL;<<<< ADD HOUR $ SUBTRACT HOUR
<<<NOW I WANT TO LESS MINUTE SO FOR MINUTE 60*24=1440
SELECT SYSDATE, SYSDATE - (30/1440) FROM DUAL;<<<< ADD MIN $ SUBTRACT MIN
<<<<<FOR SECOND 1440*60=86400
SELECT SYSDATE, SYSDATE - (30/86400) FROM DUAL;
SELECT SYSDATE, SYSDATE - (30/1440*60) FROM DUAL;

<<<<<<ALTER SESSION SET NLS_DATE_FORMAT='DD-MON-RR'; FOR DAYS
SELECT FIRST_NAME,HIRE_DATE,SYSDATE-HIRE_DATE 'NO_OF_DAYS' FROM EMPLOYEES;<<PARENTHESIS IS NOT CORRECT,DOES NOT USE'',"" IS RIGHT
SELECT FIRST_NAME,HIRE_DATE,SYSDATE-HIRE_DATE "NO_OF_DAYS" FROM EMPLOYEES;<<<CORRECT
SELECT FIRST_NAME,HIRE_DATE,(SYSDATE-HIRE_DATE/7) AS WEEKS "NO_OF_DAYS" FROM EMPLOYEES;<<WRONG
SELECT FIRST_NAME,HIRE_DATE,ROUND(SYSDATE-HIRE_DATE,0) "NO_OF_DAYS" FROM EMPLOYEES;
SELECT FIRST_NAME,HIRE_DATE,ROUND(SYSDATE-HIRE_DATE,0) "NO_OF_DAYS", ROUND((SYSDATE-HIRE_DATE)/7,0) "NO_OF_WEEKS" FROM EMPLOYEES;<<FOR DAYS AND WEEKS
SELECT FIRST_NAME,HIRE_DATE,ROUND(SYSDATE-HIRE_DATE,0) "NO_OF_DAYS", ROUND((SYSDATE-HIRE_DATE)/7,0) "NO_OF_WEEKS",ROUND((SYSDATE-HIRE_DATE)/30,0) "NO_OF_MONTH",ROUND((SYSDATE-HIRE_DATE)/12,0) "NO_OF_YEAR"  FROM EMPLOYEES;<<FOR DAYS,WEEKS,MONTH
ELECT last_name, (SYSDATE-hire_date)/7 AS WEEKS
FROM employees
WHERE department_id = 90;
<<<<<<<<<<<<DATE FUNCTION>>>>>>>>>>>>>>>>>>>>
<<<<MONTHS_BETWEEN(NUMBER OF MONTHS BETWEEN TOW DAY)
select first_name,hire_date ROUND(monthS_between(sysdate,hire_date)) "MONTH" FROM EMPLOYEES;
SELECT FIRST_NAME,HIRE_DATE, ROUND(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) "MONTH" FROM EMPLOYEES;
SELECT FIRST_NAME,LAST_NAME,HIRE_DATE, ROUND(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) "MONTH" FROM EMPLOYEES;
SELECT FIRST_NAME,LAST_NAME,HIRE_DATE, ROUND(MONTHS_BETWEEN(HIRE_DATE,SYSDATE)) "MONTH" FROM EMPLOYEES;
<<<ADD_MONTHS(ADD CALENDER MOYH TO DATE)
SELECT SYSDATE, ADD_MONTHS(SYSDATE,4) "MONTHS" FROM DUAL;
SELECT SYSDATE , ADD_MONTHS(SYSDATE,-4) "MONTHS" FROM DUAL;
<<<NEXT_DAY(WHEN WILL THE DAY COME )
SELECT SYSDATE, NEXT_DAY(SYSDATE,'SUNDAY') "NEXT_DAY" FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE-2,'FRIDAY') "NEXT_DAY" FROM DUAL;
<<<LAST_DAY(LAST DAY OF THE MONTH)
SELECT SYSDATE, LAST_DAY(SYSDATE) "LAST_DAY" FROM DUAL;
SELECT SYSDATE, LAST_DAY('15-FEB-20') "LAST_DAY" FROM DUAL;
<<<ROUND (APPLY ON DATE, 1 TO 15 VALUE GIVEN SAME MONTHAND 16 TO 30 GIVEN VALUE NEXT MONTH)
SELECT SYSDATE, ROUND(SYSDATE,'MONTH') "ROUND" FROM DUAL;
SELECT SYSDATE-15, ROUND(SYSDATE-15,'MONTH')  "ROUND_MONTH" FROM DUAL;
select sysdate, round(sysdate,'year') "round_year" from dual;
select sysdate-90, round(sysdate-90,'year') "round_year" from dual;
<<<<< trunc (truncate date, given 1 date of the  month)
select sysdate-90, TRUNC(sysdate-90,'year') "trunc_date" from dual;
SELECT SYSDATE, TRUNC(SYSDATE,'MONTH') "TRUNC" FROM DUAL;
<<<<<QTR (YEAR DEVIDED IN TO 4 PART THAT IS CALLED QTR)
SELECT SYSDATE, TRUNC(SYSDATE,'Q') "TRUNC_QTR" , ROUND(SYSDATE,'Q') "ROUND_QTR" FROM DUAL;(FIRST DAY OF QTR)

<<<GIVEN NUMBER OF DAYS
SELECT SYSDATE, ADD_MONTHS(TRUNC(SYSDATE,'Q'),3) "TRUNC_QTR" FROM DUAL;
SELECT SYSDATE, ADD_MONTHS(TRUNC(SYSDATE,'Q'),2) "TRUNC_QTR" FROM DUAL;
SELECT SYSDATE, LAST_DAY(ADD_MONTHS(TRUNC(SYSDATE,'Q'),2)) "TRUNC_QTR" FROM DUAL;
SELECT SYSDATE, LAST_DAY(ADD_MONTHS(TRUNC(SYSDATE,'Q'),2))- TRUNC(SYSDATE,'Q') FROM DUAL;

<<<<<<<<<<<<<<<<CONVERSION FUNCTION>>>>>>>>>>>>
<<<TO_CHAR (THE CHANGE OF DATE OWN MY OWN)
SELECT SYSDATE FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD-MM-RRRR') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'RRRR-MM-DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD MONTH') FROM DUAL;
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'RRRR') "TO-CHAR" FROM EMPLOYEES
ORDER BY TO_CHAR(HIRE_DATE,'RRRR');
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH" FROM EMPLOYEES;
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'RRRR')=2007;
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'DAY')='SUNDAY';<<<NO ROW SELECTED SHOW
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'DAY')='FRIDAY';<<<NO ROW SELECTED SHOW
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'DAY')='WEDNESDAY';<<<SHOW ,FOR RESION BEHIND THE 9 CORRECTYER HERE BUT IN SUNDAY, ...IN LAST HAVING 3 SPACE THAT IS RESION VALUE DOES NOT SHOW
SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH", LENGTH(TO_CHAR(HIRE_DATE,'DAY')) "LENTH_OF DAY" FROM EMPLOYEES;

SELECT FIRST_NAME,HIRE_DATE,PHONE_NUMBER, TO_CHAR(HIRE_DATE,'DAY MONTH') "TO-CHAR DAY MONTH" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'DY')='SUN';
<< IF USE FMDAY SO FM REMOVE EXTRA SPACE
SELECT FIRST_NAME,LAST_NAME,HIRE_DATE, TO_CHAR(HIRE_DATE,'DAY RRRR') "TO_CHAR DAY-YEAR",LENGTH(TO_CHAR(HIRE_DATE,'DAY')) "LENGTH_OF_DAY" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'FMDAY')='SUNDAY'; 
SELECT FIRST_NAME,LAST_NAME,HIRE_DATE, TO_CHAR(HIRE_DATE,'DAY RRRR') "TO_CHAR DAY-YEAR",LENGTH(TO_CHAR(HIRE_DATE,'DAY')) "LENGTH_OF_DAY" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'DAY')='SUNDAY   ';
SELECT FIRST_NAME,LAST_NAME,HIRE_DATE, TO_CHAR(HIRE_DATE,'DAY RRRR') "TO_CHAR DAY-YEAR",LENGTH(TO_CHAR(HIRE_DATE,'FMDAY')) "LENGTH_OF_DAY" FROM EMPLOYEES; 
SELECT FIRST_NAME,LAST_NAME,HIRE_DATE, TO_CHAR(HIRE_DATE,'DAY RRRR') "TO_CHAR DAY-YEAR" FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'RRRR')<2007;
SELECT SYSDATE, TO_CHAR(SYSDATE,'Q') "QTR" FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD/MM/RRRR HH24:MI') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE,'DD/MM/RRRR HH12:MI A.M.') FROM DUAL;
SELECT FIRST_NAME,LAST_NAME, SALARY, TO_CHAR(SALARY,'$99,999.99') "SALARY" FROM EMPLOYEES;
SELECT FIRST_NAME,LAST_NAME, SALARY, TO_CHAR(SALARY,'$99G999D99') "SALARY" FROM EMPLOYEES;<<< FOR KNOWLEDGE
SELECT FIRST_NAME,LAST_NAME, SALARY, TO_CHAR(SALARY,'$00,000.00') "SALARY" FROM EMPLOYEES;
SELECT FIRST_NAME,LAST_NAME, SALARY, TO_CHAR(SALARY,'L99,999.99') "SALARY" FROM EMPLOYEES;
<<<<<<<<<<ALTER SESSION SET NLS_CURRENCY='RS.';  <<<(CHNAGE CURRENCY)<<<<<SERCH=RUN=REGEDIT=LOCALMACHINE=SOFTWERE=ORACLE=KEY=ONSCREEN RIGHT CLICK=NEW=STRING=TYPE NLS-CURRENCY=DOUBLE CLICK=VALUE DATA=RS=OK=SYSTEM RESTART=DONE, SAME USE FOR DATE DD/MM/RRRR>>>>>>
<<<<< TO NUMBER (CHANGE IN TO NUMBER)
SELECT 5+'$66.00' FROM DUAL;<<< THIS IS WRONG
SELECT 5+TO_NUMBER('$50.66','$99.99') FROM DUAL;
SELECT * FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'RR')<08;
SELECT * FROM EMPLOYEES
WHERE HIRE_DATE < TO_DATE('01-8-08','DD-MM-YY');<<<HERE YY GET SAME CENTURY TO REDUCE FOR THIS DEFAULT USE RR FORMAT BUT RR KNOW PREVIOUS PRESENT CENTURY??????
SELECT * FROM EMPLOYEES
WHERE HIRE_DATE < TO_DATE('01-8-08');<< NOT IMP FOR MENTION

SELECT last_name, TO_CHAR(hire_date, 'DD-Mon-YYYY')
FROM employees
WHERE hire_date < TO_DATE('01-Jan-90','DD-Mon-RR');?????????

<<<<<<<<<<<<<<<<<NESTING FUNCTION>>>>>>>>>>>>>>>>>>>>>>>>>
select first_name||'last_name'||'phone_number'||'salary'||'hire_date' from employees;
select concat(FIRST_NAME,CONCAT('EMAIL',CONCAT('JOB_ID',CONCAT('PHONE_NUMBER',CONCAT('MANAGER_ID',DEPARTMENT_ID))))) FROM EMPLOYEES;
select concat(FIRST_NAME,CONCAT(EMAIL,CONCAT(JOB_ID,CONCAT(PHONE_NUMBER,CONCAT(MANAGER_ID,DEPARTMENT_ID))))) FROM EMPLOYEES;
SELECT FIRST_NAME, REPLACE(FIRST_NAME,'A','X') "REPLACE" FROM EMPLOYEES;
SELECT FIRST_NAME,SUBSTR(FIRST_NAME,1,INSTR(FIRST_NAME,'l')) FROM EMPLOYEES;
SELECT FIRST_NAME,SUBSTR(FIRST_NAME,1,INSTR(FIRST_NAME,'l')), 
SUBSTR(FIRST_NAME,INSTR(FIRST_NAME,'l'))FROM EMPLOYEES;
SELECT FIRST_NAME,SUBSTR(FIRST_NAME,1,INSTR(FIRST_NAME,'l')), 
SUBSTR(FIRST_NAME,INSTR(FIRST_NAME,'l')+1)FROM EMPLOYEES;
SELECT FIRST_NAME,REPLACE(SUBSTR(FIRST_NAME,1,INSTR(FIRST_NAME,'l')),'l','X'), 
SUBSTR(FIRST_NAME,INSTR(FIRST_NAME,'l')+1)FROM EMPLOYEES;
SELECT FIRST_NAME,CONCAT(REPLACE(SUBSTR(FIRST_NAME,1,INSTR(FIRST_NAME,'l')),'l','X'), 
SUBSTR(FIRST_NAME,INSTR(FIRST_NAME,'l')+1))FROM EMPLOYEES;
<<<<<<REGEXP BUILD FUNCTION FOR EASY TO NESTING FUNCTION
SELECT FIRST_NAME,
REGEXP_REPLACE(FIRST_NAME,'L','X',1,1) "REGEXP_REPLACE" FROM EMPLOYEES;
<<<< COL REGEXP_REPLACE FORMAT A20 >>>>FOR COLUMN FORMATING , AGAIN QUERY RUN USE  /
<<<JULIAN FUNCTION APPLY ON DATE FOR EASY WAY,JSP=JULIEN SPEL
SELECT FIRST_NAME,SALARY,TO_CHAR(TO_DATE(SALARY,'J'),'JSP') FROM EMPLOYEES;
<<<limit of built function get subtitution function,GET VALUE AND GIVEN RESULT IF NO RESULT GIVEN ERROR WITH RANGE(WHAT IS RANGE)
SELECT TO_CHAR(TO_DATE(&SALARY,'J'),'JSP') FROM DUAL;
SELECT TO_CHAR(TO_DATE(&SALARY,'J'),'JSP') FROM DUAL;<<<<NO MORE RANGE
SELECT FIRST_NAME,LAST_NAME,SALARY, LPAD(SALARY,10,'*'),RPAD(SALARY,10,'*') FROM EMPLOYEES;
SELECT FIRST_NAME,LAST_NAME,SALARY, LPAD(SALARY,10,'*'),RPAD(SALARY,10,'*'),RPAD(LPAD(SALARY,10,'*'),16,'*') FROM EMPLOYEES;<<< FOR DOUBLE PAIDING
<<<<WHICH DATE ON 14 AUGUST
SELECT SYSDATE FROM DUAL;
SELECT SYSDATE,
ADD_MONTHS(SYSDATE,+3) "ADD_MONTH"  FROM DUAL;
SELECT SYSDATE,
ADD_MONTHS(SYSDATE,+3) "MONTH",
ROUND(ADD_MONTHS(SYSDATE,+3),'MONTH') "NESTED_FIRSTDATE"  FROM DUAL;

SELECT SYSDATE,
ADD_MONTHS(SYSDATE,+3) "MONTH",
ROUND(ADD_MONTHS(SYSDATE,+3),'MONTH') "NESTED_FIRSTDATE",
ROUND(ADD_MONTHS(SYSDATE,+3),'MONTH')+13 "NESTED_2" FROM DUAL;

SELECT SYSDATE,
ADD_MONTHS(SYSDATE,3) "MONTH",
ROUND(ADD_MONTHS(SYSDATE,3),'MONTH') "NESTED_FIRSTDATE",
ROUND(ADD_MONTHS(SYSDATE,3),'MONTH')+13 "NESTED_2",
TO_CHAR(ROUND(ADD_MONTHS(SYSDATE,3),'MONTH')+13,'DD/MM DAY MONTH RRRR DDSPTH') "FINAL" FROM DUAL;

<<<<<<<<<<<<<<<<<GENERAL FUNCTION>>>>>>>>>>>>>>>
<<<<< NVL FUNCTION (CHANGE NULL VALUE IN TO ACTUAL VALUE, AND DATA TYPE THAT CAN BE USED ARE DATE ,CHARACTER AND NUMBER) AND GET VALUE SAME (DATE,DATE),(CHARACTER,CHARACTER),(NUM,NUM)
select first_name,LAST_NAME,SALARY,COMM,SALARY+COMM FROM EMPLOYEES;
select first_name,LAST_NAME,SALARY,COMMISSION_PCT,SALARY+NVL(COMMISSION_PCT,0) "TOTAL" FROM EMPLOYEES;

SELECT last_name, salary, NVL(commission_pct, 0),
(salary*12) + (salary*12*NVL(commission_pct, 0)) AN_SAL
FROM employees;

<<<<NVL2
select first_name,LAST_NAME,SALARY,COMMISSION_PCT,NVL2(COMMISSION_PCT,'SALARY+COMMISSION_PCT','SALARY') "TOTAL" FROM EMPLOYEES;<<<ONLY FOR CHECKING
select first_name,LAST_NAME,SALARY,COMMISSION_PCT,NVL2(COMMISSION_PCT,SALARY+COMMISSION_PCT,SALARY) "TOTAL" FROM EMPLOYEES;
select first_name,LAST_NAME,SALARY,NVL(HIRE_DATE,SYSDATE) "HD" FROM EMPLOYEES;<<<IF DATE NULL SO ON THE PART SET SYSDATE
SELECT FIRST_NAME,LAST_NAME,SALARY,NVL(SALARY,'NO_SALARY') "NO_SALARY" FROM EMPLOYEES;

SELECT last_name, salary, commission_pct,
NVL2(commission_pct, 
'SAL+COMM', 'SAL') income
FROM employees WHERE department_id IN (50, 80);

<<<<<< NULLIF
SELECT FIRST_NAME, LENGTH(FIRST_NAME) "EXP1",
LAST_NAME, LENGTH(LAST_NAME) "EXP2',
NULLIF(LENGTH(FIRST_NAME),LENGTH(LAST_NAME)) "NULL_IF" 
FROM EMPLOYEES; ???????????????????????????????????????????????????<<< SAME EXP GIVEN NULL VALUE IF DEFFIRENT SO GETTING FIRST VALUE

SELECT first_name, LENGTH(first_name) "expr1", 
last_name, LENGTH(last_name) "expr2",
NULLIF(LENGTH(first_name), LENGTH(last_name)) result
FROM employees;

<<<<COALESCE FUNCTION TAKE MULTIPLE ALTERNATE VALUE,f the first expression is not null, the COALESCE function returns that expression; otherwise, it does a COALESCE of the remaining expressions.

SELECT FIRST_NAME,COALESCE(COMMISSION_PCT,SALARY,1) FROM EMPLOYEES;
SELECT FIRST_NAME,COALESCE(COMMISSION_PCT,1)"RESULT" FROM EMPLOYEES;

SELECT last_name, 
COALESCE(manager_id,commission_pct, -1) comm 
FROM employees 
ORDER BY commission_pct; 

<<<<<<<<<<<<<<<<conditional expressions>>>>>>>>>>>>>>>>>>>>>>>
<<< case expression
SELECT LAST_NAME,JOB_ID,SALARY,
CASE JOB_ID WHEN 'SA_REP' THEN SALARY*1.15
WHEN 'AD_PRES' THEN SALARY*1.20                  
WHEN 'IT_PROG' THEN SALARY*1.10
WHEN 'ST_CLERK' THEN SALARY*1.25
ELSE 0
END "INCREMENT"
FROM EMPLOYEES;

SELECT FIRST_NAME,SALARY,JOB_ID,
CASE JOB_ID WHEN 'AD_VP' THEN SALARY*0.12
WHEN 'IT_PROG' THEN SALARY*0.25             
WHEN 'ST-CLERK' THEN SALARY*30
ELSE 0
END "INCREMENT",
ROUND(CASE JOB_ID WHEN 'AD_VP' THEN 1.12*salary
WHEN 'IT_PROG' THEN 1.25*salary
WHEN 'ST-CLERK' THEN 1.30*salary
ELSE SALARY
END,0 )"gross_pay"
FROM EMPLOYEES;
<<<< FOR DECODE ,CTRL + R FOR REPLACE WHEN=, /ELSE = , / THEN=, /END=)
SELECT FIRST_NAME,SALARY,JOB_ID,
DECODE( JOB_ID , 'AD_VP' , SALARY*0.12
, 'IT_PROG' , SALARY*0.25             
, 'ST-CLERK' , SALARY*30
, 0
) "INCREMENT",
ROUND(DECODE( JOB_ID , 'AD_VP' , 1.12*salary
, 'IT_PROG' , 1.25*salary
, 'ST-CLERK' , 1.30*salary
, SALARY
),0 ) "gross_pay"
FROM EMPLOYEES;

SELECT FIRST_NAME,JOB_ID,HIRE_DATE,
DECODE(TO_CHAR(HIRE_DATE, 'RRRR'),2007,1,0) FROM EMPLOYEES;

SELECT FIRST_NAME,LAST_NAME,JOB_ID,SALARY,
DECODE(TRUNC(SALARY/1000),0,0
,1,9
,2,12
,3,15
,25) "TAX"
FROM EMPLOYEES;

SELECT last_name, salary,
DECODE (TRUNC(salary/2000, 0),
0, 0.00,
1, 0.09,
2, 0.20,
3, 0.30,
4, 0.40,
5, 0.42,
6, 0.44,
0.45) TAX_RATE
FROM employees
WHERE department_id = 80;


SELECT last_name, job_id, salary,
DECODE(job_id, 'IT_PROG', 1.10*salary,
'ST_CLERK', 1.15*salary,
'SA_REP', 1.20*salary,
salary)
REVISED_SALARY
FROM employees;



SELECT last_name, job_id, salary,
CASE job_id WHEN 'IT_PROG' THEN 1.10*salary
WHEN 'ST_CLERK' THEN 1.15*salary
WHEN 'SA_REP' THEN 1.20*salary
ELSE salary END "REVISED_SALARY"
FROM employees;

desc employees
select * from employees

<<<<<<<<<<<<<<<<<<<<<<<<LEC4>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<GROUP FUNCTION
SELECT SUM(SALARY),MIN(SALARY),MAX(SALARY),ROUND(AVG(SALARY),0),COUNT(SALARY) FROM EMPLOYEES
WHERE DEPTNO=10;

SELECT SUM(SALARY),MIN(SALARY),MAX(SALARY),ROUND(AVG(SALARY),0),COUNT(SALARY) FROM EMPLOYEES
WHERE DEPARTMENT_ID=90;

SELECT SUM(SALARY),MIN(SALARY),MAX(SALARY),ROUND(AVG(SALARY),0),COUNT(SALARY) FROM EMPLOYEES
WHERE JOB_ID IN('AD_VP','IT_PROG','ST_CLERK');
SELECT MAX(HIRE_DATE),MIN(HIRE_DATE) FROM EMPLOYEES; << SUM OF ARE NOT POSSIBLE
SELECT MAX(FIRST_NAME),MIN(FIRST_NAME) FROM EMPLOYEES;
<<< WHAT IS ASCII CODE ,THE VALUE GETTING BY CORRECTER
SELECT ASCII('B') FROM DUAL;
<<<COUNT FUNCTION, TOTAL NUMBER OF RECORD
SELECT COUNT(*) FROM EMPLOYEES;
SELECT COUNT(DEPARTMENT_ID) FROM EMPLOYEES;
SELECT COUNT(*) FROM USER_OBJECTS;
SELECT COUNT(*) FROM EMPLOYEES
WHERE JOB_ID='IT_PROG';
SELECT COUNT(*) FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'RRRR')=2007;
SELECT * FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE,'RRRR')=2007;
 
SELECT COUNT(NVL(COMMISSION_PCT,0)) FROM EMPLOYEES;
SELECT COUNT(*)
FROM employees
WHERE department_id = 50;
SELECT COUNT(commission_pct)
FROM employees
WHERE department_id = 80;
<<<< USING DISTINCT KEYWORD(returns the number of distinct non-null values of exp)
SELECT COUNT(DISTINCT(DEPARTMENT_ID)) FROM EMPLOYEES;
SELECT SUM(COMMISSION_PCT), ROUND(AVG(NVL(COMMISSION_PCT,0))),COUNT(NVL(COMMISSION_PCT,0)) FROM EMPLOYEES;??????????????

SELECT COUNT(DISTINCT department_id)
FROM employees;

SELECT DEPARMENT_ID,
SUM(SALARY)
FROM EMPLOYEES;

<<<<<<<--GROUP BY CLAUSE

SELECT DEPARTMENT_ID,SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY 2 DESC;


SELECT DEPARTMENT_ID,SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY SUM(SALARY) DESC;

SELECT DEPARTMENT_ID,SUM(SALARY) "TOTAL" FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY "TOTAL" DESC;<<<ALIES USE ONLY FOR ORDER BY,NOT GROUP BY OR WHERE

SELECT DEPARTMENT_ID,JOB_ID,
SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID,JOB_ID
ORDER BY 3 ;

SELECT DEPARTMENT_ID,JOB_ID, SUM(SALARY), COUNT(*) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID,JOB_ID
ORDER BY 1,2,3;

SELECT * FROM REGIONS;
SELECT * FROM COUNTRIES;
<<< Q. IN EVERY REGION WHICH COUNTRY ARE AVAILABLE????
SELECT COUNT(*) "NO_OF_COUNTRY", REGION_ID
FROM COUNTRIES
GROUP BY REGION_ID;
<<<GROUP FUNCTION DOES NOT ALLOW TO USE WITH WHERE FUNCTION SO HERE GROUP RESTRIC BY "HAVING"
SELECT DEPARTMENT_ID, MAX(SALARY) FROM EMPLOYEES
--WHERE MAX(SALARY)>=4000 
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY)>= 4000
ORDER BY 1,2;



SELECT AVG(salary)
FROM employees
GROUP BY department_id ;

SELECT MAX(AVG(salary))
FROM employees
GROUP BY department_id;

<<<<<<<<<<<<- lec 5 >>>>>>>>>>>>>>>>
<<<<<<- type of join
<<<<NATURAL JOIN(SAME COLUMN AVAILABLE IN TWO TABLE)
DESC EMPLOYESS;
DESC DEPARTMENTS;
SELECT * FROM DEPARTMENTS;
DESC JOBS;
SELECT * FROM JOBS;
SELECT JOB_TITLE,FIRST_NAME,HIRE_DATE,SALARY FROM EMPLOYEES NATURAL JOIN JOBS;
SELECT DEPARTMENT_NAME,FIRST_NAME,LAST_NAME,HIRE_DATE,SALARY,DEPARTMENT_ID,JOB_ID,MANAGER_ID FROM EMPLOYEES NATURAL JOIN DEPARTMENTS
ORDER BY 1,6,7;

DESC COUNTRIES;
SELECT * FROM COUNTRIES;
DESC REGIONS;
SELECT * FROM REGIONS;
SELECT COUNTRY_NAME,COUNTRY_ID,REGION_NAME FROM COUNTRIES NATURAL JOIN REGIONS
ORDER BY 1,2,3;
<<<--IF COLUMN ARE NOT MATCH EVEN THEN  GETTING NATURAL JOIN IS CALLED INVALID JOIN AND DATA LOSE(DUMN,SHOCK)
SELECT COUNT(*) FROM TAB; 
CREATE TABLE EMP2 AS SELECT * FROM EMPLOYEES;
SELECT * FROM EMP2;<<DUMMY TABLE <<<<<<NATURAL JOIN ALWAY IGNORE NULL VALUE>>>>>>
SELECT FIRST_NAME,LAST_NAME,SALARY,HIRE_DATE FROM EMPLOYEES NATURAL JOIN EMP2;
<<<3 WAY JOINNING (MORE THAN TWO TABLE ARE JOIN)
DESC COUNTRIES;
DESC REGIONS;
DESC LOCATIONS

SELECT
COUNTRIES.COUNTRY_NAME,
REGIONS.REGION_NAME,
LOCATIONS.CITY
FROM COUNTRIES  JOIN REGIONS
ON(COUNTRIES.REGION_ID=REGIONS.REGION_ID)
JOIN LOCATIONS
ON(LOCATIONS.COUNTRY_ID=COUNTRIES.COUNTRY_ID)
ORDER BY 1;

SELECT
COUNTRIES.COUNTRY_NAME,
REGIONS.REGION_NAME,
LOCATIONS.CITY
FROM COUNTRIES JOIN REGIONS
ON (COUNTRIES.REGION_ID=REGIONS.REGION_ID)
JOIN LOCATIONS
ON(LOCATIONS.COUNTRY_ID=COUNTRIES.COUNTRY_ID)
JOIN DEPARTMENTS
ON(LOCATIONS.LOCATION_ID=DEPARTMENTS.LOCATION_ID)
ORDER BY 1 ;


SELECT 
DEPARTMENTS.DEPARTMENT_NAME,
SUM(EMPLOYEES.SALARY) AS 
COUNT(EMPLOYEES.SALARY),
MIN(EMPLOYEES.SALARY),    --?????????
MAX(EMPLOYEES.SALARY),
FROM EMPLOYEES JOIN DEPARTMENTS
ON (EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME
ORDER BY 1;

SELECT
LOCATIONS.CITY,
DEPARTMENTS.DEPARMENT_ID
SUM(EMPLOYEES.SALARY) "TOTAL_SALARY",
MIN(EMPLOYEES.SALARY) "MIN_EMPLOYEES",
MAX(EMPLOLYEES.SALARY) "MAX_EMPLOYEES",
COUNT(EMPLOYEES.SALARY) "TOTAL_SALARY",
FROM EMPLOYEES JOIN DEPARTMENTS
ON(EMPLOYEES.DEPARTMENT_ID=DEPARTMENTS.DEPARTMENT_ID)
JOIN LOCATIONS
ON (DEPARTMENTS.LOCATION_ID=LOCATIONS.LOCATION_ID)
GROUP BY DEPARTMENTS.DEPARTMENT_NAME,LOCATIONS.CITY
ORDER BY 1,2;
DESC DEPARMENTS

SELECT
LOCATIONS.CITY,
DEPARTMENTS.DEPARTMENT_NAME,
SUM(EMPLOYEES.SALARY) "TOTAL_SALARY",
COUNT(*) "TOTAL_EMPLOYEES",
FROM EMPLOYEES JOIN DEPARTMENTS    --??????????????????????????????????????????????????
ON(DEPARTMENTS.DEPARTMENT_ID=EMPLOYEES.DEPARTMENT_ID)
JOIN LOCATIONS
ON (DEPARTMENTS.LOCATION_ID=LOCATIONS.LOCATION_ID)
GROUP BY DEPARTMENTS.DEPARTMENT_NAME,LOCATIONS.CITY
ORDER BY 1,2;

SELECT
count(*) ,SUM(E.SALARY),d.DEPARTMENT_NAME,L.CITY
FROM EMPLOYEES e ,DEPARTMENTS d , LOCATIONS L
where d.DEPARTMENT_ID=e.DEPARTMENT_ID 

group by d.DEPARTMENT_NAME,L.CITY
--on (d.DEPARTMENT_ID=e.DEPARTMENT_ID ) --
ORDER BY 2,3;

desc locations;
select 
desc DEPARTMENTS
--JOIN LOCATIONS L --
--ON (D.LOCATION_ID=L.LOCATION_ID) --
SELECT
C.COUNTRY_NAME,
R.REGION_NAME,
L.CITY
FROM COUNTRIES C  JOIN REGIONS R
ON(C.REGION_ID=R.REGION_ID)                --ALIES NOT WORK,> NOW SOLVE
JOIN LOCATIONS L
ON(L.COUNTRY_ID = C.COUNTRY_ID)
ORDER BY 1;

SELECT employee_id, city, department_name
FROM employees e 
JOIN departments d
ON d.department_id = e.department_id  --3 WAY
JOIN locations l
ON d.location_id = l.location_id;


SELECT e.employee_id, e.last_name, e.department_id, 
d.department_id, d.location_id
FROM employees e JOIN departments d
ON (e.department_id = d.department_id);

<<<<<<<<using join(if two or more then column are same IN DEFFIRENT TABLE SO BY USING JOIN USE FOR JOIN COLUMN BY CHOICE),EQUI JOIN(NATURAL JOIN,ON CLAUSE JOIN,USING JOIN) 
SELECT DEPARTMENT_NAME, FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID
FROM EMPLOYEES JOIN DEPARTMENTS
USING(DEPARTMENT_ID);
<<-ALIAS NOT USE WITHJ USING CLAUSE AND THAT PART USE IN THE BRAKET OF USING THERE IS SAME PART WRITE UPPER SIDE NOT GIVEN ALIAS
SELECT 
E. FIRST_NAME,
E. SALARY,
D. DEPARTMENT_NAME,
E.SALARY
DEPARTMENT_ID
FROM EMPLOYEES E JOIN DEPARTMENTS D
USING(DEPARTMENT_ID);
<<<<<ALTER TABLE EMPLOYEES RENAME COLUMN DEPARTMENT_ID TO DEPARTMENTID
SELECT 
E. FIRST_NAME,
E. SALARY,
D. DEPARTMENT_NAME,
E.SALARY
DEPARTMENT_ID
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON(D.DEPARTMENT_ID=E.DEPARTMENTID)<<<< HERE IN ON CLAUSE COLUMN NAME DEFFIRENT BUT THE DATA ARE SAME SO ITS GIVEN THE ANS AND OTHER PROFIT IS ON CLAUSE ARE JOIN DEFFIRENT COLUMN THAT IS CALLED NON EQUI JOIN(NOT POSSIBLE BY NATURAL JOIN OR USING JOIN)

SELECT employees.employee_id, employees.last_name, 
departments.location_id, department_id
FROM employees JOIN departments
USING (department_id) ;

SELECT e.last_name, e.salary, j.grade_level
FROM employees e JOIN job_grades j               --NON EQUI JOIN
ON e.salary 
BETWEEN j.lowest_sal AND j.highest_sal;

<<<-- SELF JOIN GET THE INFORMETION BY OWN TABLE JOIN DEFFIRENT COLUMN <<< TO WHOM THE EMPLYESS ARE REPORTING ???????????
SELECT * FROM EMPLOYEES;

SELECT E.EMPLOYEE_ID, E.FIRST_NAME,
M.MANAGER_ID
FROM EMPLOYEES E JOIN EMPLOYEES M   --????????????? 100 ID NOT SHOW 
ON(E.MANAGER_ID=M.EMPLOYEE_ID)
ORDER BY 1,2,3;
SELECT * FROM EMPLOYEES;

SELECT E.EMPLOYEE_ID, E.FIRST_NAME,
M.MANAGER_ID
FROM EMPLOYEES E , EMPLOYEES M   --<<<<<<<<<<<<SECOND METHOD
WHERE(E.MANAGER_ID=M.EMPLOYEE_ID)
ORDER BY 1,2,3,4;

SELECT e.last_name emp, m.last_name mgr
FROM employees e JOIN employees m
ON (e.manager_id = m.employee_id);

<<<<<<ADDITIONAL CONDITION
SELECT e.employee_id, e.last_name, e.department_id, 
d.department_id, d.location_id
FROM employees e JOIN departments d
ON (e.department_id = d.department_id)
AND e.manager_id = 149 ;

<<<<<-- OUTER JOIN ((RIGHT,LEFT,FULL)OUTER JOIN)
<<<--RIGHT OUTER JOIN MENS  GET ALL DATA FROM DEPARTMENT TABLE WHETHER MATCHING OR NOT
SELECT
E.FIRST_NAME,
E.JOB_ID,
E.SALARY,
D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON(E.DEPARTMENT_ID=D.DEPARTMENT_ID)
ORDER BY 1,2,3;
<<<<<<LEFT OUTER JOIN
SELECT
E.FIRST_NAME,
E.JOB_ID,
E.SALARY,
D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON(E.DEPARTMENT_ID=D.DEPARTMENT_ID)
ORDER BY 1,2,3;

SELECT e.last_name, e.department_id, d.department_name
FROM employees e LEFT OUTER JOIN departments d
ON (e.department_id = d.department_id) ;

<<<<<FULL OUTER JOIN (GETTING BOTH SIDE MATCH AND UNMATCH DATA)
SELECT
E.FIRST_NAME,
E.JOB_ID,
E.SALARY,
D.DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON(E.DEPARTMENT_ID=D.DEPARTMENT_ID)
ORDER BY 1,2,3;

SELECT e.last_name, d.department_id, d.department_name
FROM employees e FULL OUTER JOIN departments d
ON (e.department_id = d.department_id) ;

<<<<<CROSS JOIN
SELECT FIRST_NAME,LAST_NAME,SALARY FROM EMPLOYEES   --<<<MULTIPLY DATA THEN DATA LOSE AND NOT MORE USE(EMPLOYEES RECORD ID 107 AND DEPARTMENTS RECORD IS 15 SO CROSS JOIN MAKE MULTIPLE RECORD OVER HERE)
CROSS JOIN DEPARTMENTS;
SELECT FIRST_NAME,LAST_NAME,SALARY FROM EMPLOYEES  --<<<< COLUMN ARE NOT MATCH SO THIS MAKE IT CROSS JOIN
NATURAL JOIN DEPARTMENTS;

SELECT *  FROM DEPARTMENTS


SELECT e.last_name, e.department_id, d.department_name
FROM employees e RIGHT OUTER JOIN departments d
ON (e.department_id = d.department_id) ;

SELECT FIRST_NAME,LAST_NAME,SALARY FROM EMPLOYEES,DEPARMENTS;  --CROSS 3 BECAUSE OF WHERE CONDITION NOT MENTION <<<<JOIN  ?????

<<<<<<<<<<<<<<<<<<<<<<<<LEC 6>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<-- MAIN QUERY IS CALLED OUTER QUERY AND INNER QUERY IS CALLED INNER QUERY(SUBQUERY);

SELECT SALARY FROM EMPLOYEES
WHERE LAST_NAME='abel'

SELECT LAST_NAME FROM EMPLOYEES
where salary >1100;

SELECT LAST_NAME,JOB_ID,SALARY 
FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY FROM EMPLOYEES WHERE LAST_NAME ='Abel')

SELECT LAST_NAME,SALARY,JOB_ID
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE LAST_NAME = 'Russell');
AND LAST_NAME <>'Russell'; ?????

SELECT * FROM EMPLOYEES
WHERE HIRE_DATE > (SELECT HIRE_DATE FROM EMPLOYEES WHERE EMPLOYEE_ID = 105);

SELECT last_name, salary
FROM employees
WHERE salary >
(SELECT salary
FROM employees
WHERE last_name = 'Abel');

<<<<single row subquery (single oprater show with the subquery)
select * from employees
where salary >(select salary from employees where job_ID= 'AD_VP')  --<< FOR RESION SIGLE ROW SUBQUERY SHOW ONLY ONE ROW BUT I HAVE AD_VP MOR ID ARE AVILABLE

SELECT * FROM EMPLOYEES
WHERE SALARY > (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME ='AHMAD'); --<<AHMAD NOT AVAILABLE SO TABLE VALUE NOT SHOW

SELECT * FROM EMPLOYEES
WHERE
JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID =141) AND 
SALARY > (SELECT  SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID =143);

SELECT * FROM EMPLOYEES
WHERE
DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID =141) AND 
SALARY > (SELECT  SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID =143);

SELECT * FROM EMPLOYEES
WHERE
DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID =141) OR
SALARY > (SELECT  SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID =143);

SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 143 );

SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID

SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (108,102)  --<<CHECK VALUE ,SO THERE ARE USE MULTIPLE COLUMN

SELECT last_name, job_id, salary
FROM employees
WHERE job_id = 
(SELECT job_id
FROM employees
WHERE employee_id = 141)
AND salary >
(SELECT salary
FROM employees
WHERE employee_id = 143);

<<--USING GROUP FUNCTION IN SUBQUERY
SELECT * FR0M EMPLOYEES
WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID );

SELECT FIRST_NAME,LAST_NAME,SALARY FROM EMPLOYEES 
WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEES) GROUP BY DEPARTMENT_ID ); --< IF GIVEN GROUP BY DEPARTMENT_ID THEN I AM GETTING MORE RESULT SO QURY SHOW ERROR

SELECT FIRST_NAME,LAST_NAME,SALARY FROM EMPLOYEES 
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEES)

SELECT last_name, job_id, salary
FROM employees
WHERE salary = 
(SELECT MIN(salary)
FROM employees);

SELECT SALARY,FIRST_NAME,LAST_NAME FROM EMPLOYEES 
WHERE salary = (SELECT MIN(salary) FROM employees GROUP BY DEPARTMENT_ID );

<<<<<<<<<<<sub query use in having clause
desc employees;
SELECT SALARY,FIRST_NAME,LAST_NAME FROM EMPLOYEES  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

SELECT DEPARTMENT_ID ,SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY)> (SELECT AVG(SALARY)FROM EMPLOYEES); -- GIEVEN SUM OF SALARY WHOSE SALARY MORE THAN AVG
SELECT AVG(SALARY)FROM EMPLOYEES

SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) >
(SELECT MIN(salary)
FROM employees
WHERE department_id = 50);

SELECT employee_id, last_name
FROM employees
WHERE salary =
(SELECT MIN(salary)
FROM employees
GROUP BY department_id);

ELECT last_name, job_id
FROM employees
WHERE job_id =
(SELECT job_id
FROM employees
WHERE last_name = 'Haas');

<<<<MULTIPLE SUB QUERY
SELECT DISTINCT FIRST_NAME,SALARY,JOB_ID FROM EMPLOYEES
WHERE JOB_ID='IT_PROG'
ORDER BY 1;
--FIND EMPLOYEE HAVING SALARY SALES MAN TOP SALARY
SELECT * FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID > 'IT_PROG');<< HIGH FROM IT_PROG THEREFORE IT_PROG NOT SHOW BECAUSE OF IT_PROG IS LESSTHAN COMPARE TO OTHER ID

SELECT * FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG');

SELECT * FROM EMPLOYEES
WHERE SALARY < ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG'); -- HIGH SALARY FROM LESS AMOUNT

SELECT * FROM EMPLOYEES
WHERE SALARY <ANY (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG') -- LOW RECORD FROM TOP SALARY,<ANY MENS MAXIMUM FROM LESSTHAN
AND JOB_ID <> 'IT_PROG'
ORDER BY SALARY DESC;

SELECT * FROM EMPLOYEES
WHERE SALARY >ANY (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG') -- HIGH RECORD FROM LOW SALARY,<ANY MENS MAXIMUM FROM LESSTHAN
AND JOB_ID <> 'IT_PROG'
ORDER BY SALARY DESC;

SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ANY
(SELECT salary
FROM employees
WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';

SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ALL
(SELECT salary
FROM employees
WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';

SELECT emp.last_name
FROM employees emp
WHERE emp.employee_id NOT IN
(SELECT mgr.manager_id
FROM employees mgr);

SELECT * FROM EMPLOYEES WHERE JOB_ID='IT_PROG'
SELECT * FROM EMPLOYEES;


<<<<<<<<<<<<<<<<<<<<<<lec 7>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<--UNION ALL (DISPLAY CURRENT AND PREVIOUS JOB DETAIL OF ALL EMPLOYEES)(DISPLAY EACH COMBINATION  ONLY ONXCE) (AND REMOVING DUBLICATE VALUE),column name is not compry for same but data type even same
SELECT EMPLOYEE_ID,JOB_ID FROM EMPLOYEES
UNION
SELECT EMPLOYEE_ID,JOB_ID FROM JOB_HISTORY;


SELECT EMPLOYEE_ID,JOB_ID FROM EMPLOYEES
EXCEPT
SELECT EMPLOYEE_ID,JOB_ID FROM JOB_HISTORY;

COLUMN a_dummy NOPRINT
SELECT 'sing' AS "My dream", 3 a_dummy
FROM dual
UNION
SELECT 'I''d like to teach', 1 a_dummy
FROM dual
UNION 
SELECT 'the world to', 2 a_dummy
FROM dual
ORDER BY a_dummy;



<<<<<UNION ALL (The UNION ALL operator returns results from both queries, including all duplications.) and equal number of column are compasary
SELECT EMPLOYEE_ID,JOB_ID,DEPARTMENT_ID FROM EMPLOYEES
UNION ALL
SELECT EMPLOYEE_ID,JOB_ID,DEPARTMENT_ID FROM JOB_HISTORY
ORDER BY 1,2,3;




<<<<INTERSECT Operator (The INTERSECT operator returns rows that are  common to both queries.)
SELECT JOB_ID,EMPLOYEE_ID FROM EMPLOYEES
INTERSECT
SELECT JOB_ID,EMPLOYEE_ID FROM JOB_HISTORY;



<<<<MINUS OPREATOR(he MINUS operator returns rows in the first query that are not present in the second query.)
SELECT EMPLOYEE_ID FROM EMPLOYEES
MINUS
SELECT EMPLOYEE_ID FROM JOB_HISTORY;


<<<<<<<<<<<<<<<<<<<<<<<<<lac 8 >>>>>>>>>>>>>>>>>>>>>>>>>>
--<<<<<<MANIPULATING DATA
<<<<< Describe each data manipulation language (DML) 
statement
 Insert rows into a table
 Update rows in a table
 Delete rows from a table
 Control transactions


<<<<<<<<<<<ROW INSERT
INSERT INTO DEPARTMENTS(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID) VALUES (271,'SALES',206,2000);
INSERT INTO DEPARTMENTS(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID) VALUES (273,'SAL',211,3200);

INSERT INTO DEPARTMENTS(DEPARTMENT_ID,DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID) VALUES (274,'SALES1',NULL,NULL);

INSERT INTO departments
VALUES (100, 'Finance', 208, 2100);

INSERT INTO departments(department_id, 
department_name, manager_id, location_id)         --NO WORK
VALUES (70, 'Public Relations', 100, 1700);

INSERT INTO departments(department_id, 
department_name, manager_id, location_id)              -- NO WORK
VALUES (70, 'Public Relations', 100, 1700);
<<<<<<SYSDATE INSERT
INSERT INTO employees (employee_id, 
first_name, last_name, 
email, phone_number,
hire_date, job_id, salary,                 ???????????????????????????????
commission_pct, manager_id,
department_id)
VALUES ('Den', 'Raphealy', 
'DRAPHEAL', '515.127.4561',TO_DATE('FEB 25, 2022','MON DD,RRRR'),'AC_ACCOUNT', 11000, NULL, 100, 30);

<<<<<<<<<<INSERT INTO ANOTHER TABLE

INSERT INTO employees
VALUES (114, 
'Den', 'Raphealy', 
'DRAPHEAL', '515.127.4561',            ??????????????????????????????????
TO_DATE('FEB 3, 1999', 'MON DD, YYYY'),
'AC_ACCOUNT', 11000, NULL, 100, 30);

INSERT INTO sales_reps(id, name, salary, commission_pct)
SELECT employee_id, last_name, salary, commission_pct         ??????????????????????????????
FROM employees
WHERE job_id LIKE '%REP%';

<<<<<<<<<<UPDAT
UPDATE SET DAPARTMENT_ID=70
WHERE EMPLOYEE_ID=113;

<<<<<<UPDATE TWO COLUMN WITH SUBQUERY
UPDATE EMPLOYEES SET JOB_ID =(SELECT JOB_ID FROM EMPLOYEES 
                 WHERE EMPLOYEE_ID = 102)                      ?????????????????????????????
         SALARY=(SELECT SALARY FROM EMPLOYEES
                WHERE EMPLOYEE_ID=102)
WHERE DEPARTMENT_ID = 207;
                 
UPDATE employees
SET job_id = (SELECT job_id 
FROM employees 
WHERE employee_id = 205), 
salary = (SELECT salary 
FROM employees 
WHERE employee_id = 205) 
WHERE employee_id = 114;


UPDATE copy_emp
SET department_id = (SELECT department_id
FROM employees
WHERE employee_id = 100)                           ??????????????????????
WHERE job_id = (SELECT job_id
FROM employees
WHERE employee_id = 200);

<<<<<<<<Deleting Rows from a Table
DELETE FROM DEPARTMENTS
WHERE DEPARTMENT_ID =102;    <<<<ONE ROW DELETE

DELETE FROM EMPLOYES ;     <<<<<<<<<<ALL ROW DELETE

<<<<<<Deleting Rows Based  on Another Table
ELETE FROM employees
WHERE department_id =
(SELECT department_id
FROM departments
WHERE department_name 
LIKE '%Public%');

<<<<<<<<<<<TRUNCATE Statement
<<<<<<<< Removes all rows from a table, leaving the table empty and the table structure intact
TRUNCATE FROM COPY_EMP

<<<<<Using a Subquery in an INSERT Statement
INSERT INTO
(SELECT employee_id, last_name,
email, hire_date, job_id, salary, 
department_id
FROM employees
WHERE department_id = 50) 
VALUES (99999, 'Taylor', 'DTAYLOR',
TO_DATE('07-JUN-99', 'DD-MON-RR'),
'ST_CLERK', 5000, 50);

erify the results:
SELECT employee_id, last_name, email, hire_date, 
job_id, salary, department_id
FROM employees
WHERE department_id = 50;

<<<<<<<<<<<<<<<<<Database Transactions
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


DESC DEPARTMENTS;
SELECT * FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;

<<<<<<<<<<lec9 Using DDL Statements to Create and Manage Tables>>>>>>>>>>>>>>>
<<<DEFAULT OPTION
create table emp as (select * from  employees )
select * from emp
CREATE TABLE WORKER$(
WORK_ID NUMBER(20) PRIMARY KEY,
WORKER_NAME VARCHAR(50),
DEPARTMENT VARCHAR(50),
SALARY NUMBER(10) DEFAULT (5000));

CREATE TABLE EMP4 AS (SELECT * FROM EMP2)
SELECT * FROM EMP2

CREATE TABLE EMP3(
EMP_ID NUMBER(20) PRIMARY KEY,
ENAME VARCHAR(255),
SALARY NUMBER(20) DEFAULT (5000)
);
DROP TABLE EMP3;
INSERT INTO EMP3(EMP_ID,ENAME,SALARY) VALUES (1,'SHAHRUKH',1000);
INSERT INTO EMP3(EMP_ID,ENAME,SALARY) VALUES (2,'SALAM JO',400);
INSERT INTO EMP3(EMP_ID,ENAME) VALUES (3,'RAMESH');
SELECT * FROM EMP3;

CREATE TABLE EMP5(E_ID NUMBER(20),SALARY NUMBER(20) DEFAULT(5000),HIRE_DATE DATE DEFAULT SYSDATE);
INSERT INTO EMP5 VALUES (1,'03 FEB, 2004' ,'DD MON,RRRR')
INSERT INTO EMP5 (E_ID,SALARY) VALUES (1,4000);
DROP TABLE EMP5;
SELECT * FROM EMP5

<<<<<<<<<<<<DATA TYPE
<<<<<<<<<Datetime Data Types
<<<<TIMESTAMP
TIMESTAMP[(fractional_seconds_precision)]
TIMESTAMP[(fractional_seconds_precision)] WITH TIME ZONE
TIMESTAMP[(fractional_seconds_precision)] WITH LOCAL TIME ZONE
<<<< INTERVAL YEAR TO MONTH
NTERVAL YEAR [(year_precision)] TO MONTH
<<<< INTERVAL DAY TO SECOND                                           ??????????????????????????? HOW TO USE
INTERVAL DAY [(day_precision)] 
TO SECOND [(fractional_seconds_precision)]
<<<<<<<<<Defining Constraints  ???????
<<<<<<<<<Including Constraints
-NOT NULL
 UNIQUE 
 PRIMARY KEY
 FOREIGN KEY
 CHECK
<<<<

CREATE TABLE Temployees01(
employee_id NUMBER(6)
CONSTRAINT emp_emp_id_pk PRIMARY KEY,
first_name VARCHAR2(20));

<<<<<<NOT NULL Constraint (MOSTLY USE FOR EMPLOYE_ID,DEPARTMENT-ID,HIRE_DATE)
CREATE TABLE STUDENT(
S_ID NUMBER(20),
S_NAME VARCHAR2 (50) NOT NULL
);
DROP TABLE STUDENT;
INSERT INTO STUDENT(S_ID,S_NAME) VALUES (01,'SHAHRUKH_KHAN');

<<<<<UNIQUE (USE MOSTLY LIKE EMAIL-ID) NOT GIVEN SAME NAME IN OTHER ROW
CREATE TABLE STUDENTS(
STD_ID NUMBER(20),
STD_NAME VARCHAR2(50) UNIQUE
);
INSERT INTO STUDENTS(STD_ID,STD_NAME) VALUES (01,'SRK')
INSERT INTO STUDENTS(STD_ID,STD_NAME) VALUES (02,'SRK')

CREATE TABLE employees(
employee_id NUMBER(6),
last_name VARCHAR2(25) NOT NULL,
email VARCHAR2(25),
salary NUMBER(8,2),
commission_pct NUMBER(2,2),
hire_date DATE NOT NULL,
... 
CONSTRAINT emp_email_uk UNIQUE(email));

<<<PRIMARY KEY Constraint (USE FOR UNIQLY IDENTIFY), AND FOREN KEY (DIFFINE PRIMARY KEY FROM OTHER TABLE)
CREATE TABLE DEPARTMENT(DEP_ID NUMBER(20) PRIMARY KEY,DEP_NAME VARCHAR2(20));
CREATE TABLE COMPANY2(EMP_ID NUMBER PRIMARY KEY,EMP_NAME VARCHAR(50),DEP_ID NUMBER REFERENCES DEPARTMENT)
INSERT INTO DEPARTMENT VALUES(1,'IT');
INSERT INTO DEPARTMENT VALUES(2,'SALES');
INSERT INTO DEPARTMENT VALUES(3,'TEC');
INSERT INTO COMPANY2 VALUES(1,'MEDICAL',1);
INSERT INTO COMPANY2 VALUES(2,'MEDICA',2);
INSERT INTO COMPANY2 VALUES(3,'MEDI',3);
INSERT INTO COMPANY2 VALUES(4,'MED',4);
select * from DEPARTMENT;
SELECT * FROM COMPANY2;
CREATE TABLE employees(
employee_id NUMBER(6),
last_name VARCHAR2(25) NOT NULL,
email VARCHAR2(25),
salary NUMBER(8,2),
commission_pct NUMBER(2,2),
hire_date DATE NOT NULL,
...
department_id NUMBER(4),
CONSTRAINT emp_dept_fk FOREIGN KEY (department_id)    --<<?????????????????????????????
REFERENCES departments(department_id),
CONSTRAINT emp_email_uk UNIQUE(email));

CREATE TABLE AMAZON(
EMP_ID NUMBER NOT NULL PRIMARY KEY ,
LAST_NAME VARCHAR2(100),
EMAIL VARCHAR(100),
SALARY NUMBER (10,2) NOT NULL CONSTRAINT EMP_SAL_MIN CHECK (SALARY>0),
COMMISION_PCT NUMBER,
HIRE_DATE DATE NOT NULL,
DEPARTMENT_ID NUMBER);

INSERT INTO AMAZON VALUES (1,'SHARMA','SHARMA@',200,5,'02-5-2001',10);
INSERT INTO AMAZON VALUES (2,'VARMA','VERMA@',100,5,'02-5-2001',20);
INSERT INTO AMAZON VALUES (3,'KHAN','KHAN@',300,5,'02-5-2001',30);
INSERT INTO AMAZON VALUES (4,'RAJPUT','RAJPUT@',200,5,'02-5-2001',40);
INSERT INTO AMAZON VALUES (5,'YADAV','YADAV@',400,5,'02-5-2001',50);
INSERT INTO AMAZON VALUES (6,'ANSARI','ANSARI@',500,5,'02-5-2001',60);

UPDATE AMAZON SET DEPARTMENT_ID=60
WHERE DEPARTMENT_ID=600;
SELECT * FROM AMAZON;

CREATE TABLE UBER(
EMP_ID NUMBER NOT NULL ,
LAST_NAME VARCHAR2(100),
EMAIL VARCHAR(100),
SALARY NUMBER (10,2) NOT NULL CONSTRAINT uber_SAL_MIN CHECK (SALARY>0),
COMMISION_PCT NUMBER,
HIRE_DATE DATE NOT NULL,
DEPT_ID NUMBER,
CONSTRAINT ber_ment_rgn FOREIGN KEY (DEPT_ID) REFERENCES AMAZON(EMP_ID));

insert into UBER values (7,'king','king@',500,4,'03/04/2002',1);
insert into UBER values (8,'KUMAR','king@',500,4,'03/04/2002',2);
insert into UBER values (9,'RAMESH','king@',500,4,'03/04/2002',3);
insert into UBER values (10,'VINOD','king@',500,4,'03/04/2002',4);
insert into UBER values (10,'VINOD','king@',500,4,'03/04/2002',5);
ALTER TABLE UBE_DEPT_FK DROP CONSTRAINT UBER_depart_FK ;

DROP TABLE AMAZON
DROP TABLE UBER 
select * from uber;
SELECT * FROM AMAZON
CREATE TABLE FLIPCART(
EMP_NAME VARCHAR2(100),
EMAIL_ID VARCHAR(100) UNIQUE,
SALARY NUMBER (10,2) NOT NULL CONSTRAINT FLIP_SALARY_MIN CHECK (SALARY>0),
COMMISION_PCT NUMBER,
HIRE_DATE DATE NOT NULL,
DEPARTMENT_ID NUMBER,
EMP_ID REFERENCES AMAZON
);

DROP TABLE FLIPCART

CREATE TABLE FLIPCART(
EMP_NAME VARCHAR2(100),
EMAIL_ID VARCHAR UNIQUE(100),
SALARY NUMBER (10,2) NOT NULL CONSTRAINT FLIP_SAL_MIN CHECK (SALARY>0),
COMMISION_PCT NUMBER,
HIRE_DATE DATE NOT NULL,
DEPT_ID NUMBER,
CONSTRAINT FLIP_dept_FK  FOREIGN KEY (DEPT_ID) REFERENCES AMAZON(DEPARTMENT_ID)
);

DROP TABLE AMAZON;
FLIPCART_DEPARTMENT_ID_FKEY
FLIPCART_EMAIL_UN
CONSTRAINT
CONSTRAINT FLIPCART_EMAIL_ID_UN  UNIQUE(EMAIL_ID)
<<<<CHECK Constraint

CREATE TABLE employe
( employee_id NUMBER(6)
CONSTRAINT emp_employee_id PRIMARY KEY
, first_name VARCHAR2(20)
, last_name VARCHAR2(25)
CONSTRAINT emp_last_name_nn NOT NULL
, email VARCHAR2(25)
CONSTRAINT emp_email_nn NOT NULL
CONSTRAINT emp_email_uk UNIQUE
, phone_number VARCHAR2(20)
, hire_date DATE
CONSTRAINT emp_hire_date_nn NOT NULL
, job_id VARCHAR2(10)
CONSTRAINT emp_job_nn NOT NULL
, salary NUMBER(8,2)
CONSTRAINT emp_salary_ck CHECK (salary>0)
, commission_pct NUMBER(2,2)
, manager_id NUMBER(6)
, department_id NUMBER(4)
CONSTRAINT emp_dept_fk REFERENCES
departments (department_id));

DESC EMPLOYEES
DESC DEPARTMENTS

CREATE TABLE dept80
AS 
SELECT employee_id, last_name, 
salary*12 ANNSAL, 
hire_date
FROM employees
WHERE department_id = 80;

<<<<< TABLE CREATED BY SUBQUERY
CREATE TABLE ABC
AS
SELECT EMP_ID,SALARY,DEPARTMENT_ID FROM AMAZON
WHERE DEPARTMENT_ID = 10;



<<<<<<<<<<<<<lec 10>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Creating Other Schema Objects
<<<<<view
select* from amazon;
CREATE VIEW salvu50
AS SELECT employee_id ID_NUMBER, last_name NAME,
salary*12 ANN_SALARY
FROM employees
WHERE department_id = 50;

SELECT *
FROM salvu50;

CREATE OR REPLACE VIEW empvu80
(id_number, name, sal, department_id)
AS SELECT employee_id, first_name || ' ' --<<<< what is the meanming of ||''||
|| last_name, salary, department_id
FROM employees
WHERE department_id = 80;

select * from empvu80

<<<complex query
CREATE OR REPLACE VIEW dept_sum_vu
(name, minsal, maxsal, avgsal)
AS SELECT d.department_name, MIN(e.salary), 
MAX(e.salary),AVG(e.salary)
FROM employees e JOIN departments d
ON (e.department_id = d.department_id)
GROUP BY d.department_name;

select * from dept_sum_vu;
<<<<< with check view
CREATE OR REPLACE VIEW empvu20
AS SELECT *
FROM employees
WHERE department_id = 20
WITH CHECK OPTION CONSTRAINT empvu20_ck ;

< <<< denying  operation 
CREATE OR REPLACE VIEW empvu10
(employee_number, employee_name, job_title)
AS SELECT employee_id, last_name, job_id
FROM employees
WHERE department_id = 10
WITH READ ONLY ;                     ???????????????why use read only

select * from empvu10;
<<<<<<sequence 
create  table student1(std_id number primary key,std_name varchar2(20));
CREATE SEQUENCE STD_SEQ INCREMENT BY 1 START WITH 100
MAXVALUE 999 MINVALUE 1 NOCACHE NOCYCLE NOORDER;
INSERT INTO STUDENT1 VALUES (STD_SEQ.NEXTVAL,'KHAN');
SELECT*FROM STUDENT1;

CREATE SEQUENCE DEPT_ID_seq
INCREMENT BY 5
START WITH 120
MAXVALUE 9999
NOCACHE
NOCYCLE;

INSERT INTO departments(department_id, 
department_name, location_id)
VALUES (DEPT_ID_SEQ.NEXTVAL, 
'SupporT', 2500);
SELECT * FROM DEPARTMENTS;
ALTER TABLE DEPARTMENTS DROP CONSTRAINT DEPT_ID_PK ;
DROP SEQUENCE DEPT_ID_SEQ;
DROP SEQUENCE dept_deptid_seq;
<<<<<<< MODIFY SEQUENCE
ALTER SEQUENCE dept_deptid_seq
INCREMENT BY 20
MAXVALUE 999999
NOCACHE
NOCYCLE;

<<<<<INDEXES
CREATE INDEX emp_last_name_idx
ON employees(last_name);








<<<<<SYNONYM (LARGE TABLE NAME CONVERT INTO SHORT NAME BY USING SYNONEMS)

CREATE [PUBLIC] SYNONYM synonym
FOR object;
CREATE SYNONYM EMP
FOR EMPLOYEES

CREATE SYNONYM d_sum
FOR dept_sum_vu;

SELECT * FROM d_sum;

DROP SYNONYM d_sum;

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<lec 11 >>>>>>>>>>>>>>>>>>>>>>>>>
<<<data dictionary structure user,all,dba,v$

desc dictionary;
select * from dictionary
where table_name = 'USER_OBJECTS';
<<<USER OBJECT VIEW
SELECT object_name, object_type, created, status
FROM user_objects
ORDER BY object_type;

<<<TABLE INFORMATION
DESC USER_TABLES;
SELECT TABLE_NAME FROM USER_TABLES;
DESC ALL_TABLES;
SELECT TABLE_NAME FROM ALL_TABLES;

<<<<<COLUMN INFORMATION
DESC USER_TAB_COLUMNS

SELECT column_name, data_type, data_length,
data_precision, data_scale, nullable
FROM user_tab_columns
WHERE table_name = 'EMPLOYEES';

<<<<<<CONSTRAINT INFORMATION
DESC USER_CONSTRAINTS;

SELECT constraint_name, constraint_type,
search_condition, r_constraint_name, 
delete_rule, status
FROM user_constraints
WHERE table_name = 'EMPLOYEES'; 

DESCRIBE user_cons_columns

SELECT constraint_name, column_name
FROM user_cons_columns
WHERE table_name = 'EMPLOYEES'; 

<<<VIEW INFORMATION
DESC USER_VIEWS;
SELECT DISTINCT view_name FROM user_views;
SELECT text FROM user_views
WHERE view_name = 'EMP_DETAILS_VIEW';

<<<<<<SEQUENCE INFORMATION
DESC USER_SEQUENCES;
SELECT sequence_name, min_value, max_value, 
increment_by, last_number
FROM user_sequences;

<<<SYNONYMS INFORMATION
DESC USER_SYNONYMS;

SELECT * 
FROM user_synonyms;
<<<<ADDING COMMENT
COMMENT ON TABLE employees
IS 'Employee Information';

<<SET LINESIZE 100
<<SHOW USER;
<<COLUMN CONSTRAINT_NAME FOR A20;
<<COLUMN TABLE_NAME FOR A20;

SELECT NAME FROM V$DATABASE;
desc v$database;

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<book 2>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<lec2>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<managing schema object
Use the ALTER TABLE statement to:
 Add a new column
 Modify an existing column
 Define a default value for the new column
 Drop a column
alter table dept80
add (job_iod varchar(20));
alter table amazon
add job_id varchar(20);
<<<mnodifying a column (You can change a columns data type, size, and default value.)
ALTER TABLE AMAZON
MODIFY LAST_NAME VARCHAR(20);
SELECT * FROM AMAZON;
<<DROPING A COLUMN
ALTER TABLE AMAZON
DROP UNUSED COLUMNS;
<<<SET UNUSED OPTION (You use the SET UNUSED option to mark one or more columns as unused.)
ALTER TABLE AMAZON
SET UNUSED (JOB_ID);

ALTER TABLE AMAZON
SET UNUSED COLUMN JOB_ID;

ALTER TABLE AMAZON
DROP UNUSED COLUMNS; 
<<<ADDING CONSTRAINT SYNTAX
alter table amazon
MODIFY EMP_ID PRIMARY KEY; 

ALTER TABLE AMAZON
ADD CONSTRAINT AMA_ID_FK FOREIGN KEY (MANGER_ID) REFERENCES AMAZON(EMP_ID);

ALTER TABLE emp2
modify employee_id Primary Key;

ALTER TABLE emp2
ADD CONSTRAINT emp_mgr_fk 
FOREIGN KEY(manager_id) 
REFERENCES emp2(employee_id);

ALTER TABLE Emp2 ADD CONSTRAINT emp_dt_fk 
FOREIGN KEY (Department_id)                             ????????????????????????
REFERENCES departments ON DELETE CASCADE); 

ALTER TABLE dept2
ADD CONSTRAINT dept2_id_pk 
PRIMARY KEY (department_id)
DEFERRABLE INITIALLY DEFERRED

SET CONSTRAINTS dept2_id_pk IMMEDIATE

ALTER SESSION 
SET CONSTRAINTS= IMMEDIATE

<<<<<<<DROPING CONSTRAINT
ALTER TABLE emp2
DROP CONSTRAINT emp_mgr_fk;

<<<<<<<<<Remove the PRIMARY KEY constraint on the DEPT2 table 
and drop the associated FOREIGN KEY constraint on the 
EMP2.DEPARTMENT_ID column:

ALTER TABLE dept2
DROP PRIMARY KEY CASCADE;

<<<<<<<<<<<<<DESABLING CONSTRAINT
ALTER TABLE emp2
DISABLE CONSTRAINT emp_dt_fk;
<<<<<<<<<ENABLE CONSTRAINT (ctivate an integrity constraint currently disabled in the table definition by using the ENABLE clause.)
<<A UNIQUE index is automatically created if you enable a UNIQUE key or a PRIMARY KEY constraint.
ALTER TABLE emp2
ENABLE CONSTRAINT emp_dt_fk;

<<<<<Cascading Constraints
<<
ALTER TABLE emp2 
DROP COLUMN employee_id CASCADE CONSTRAINTS;
ALTER TABLE test1
DROP (pk, fk, col1);


